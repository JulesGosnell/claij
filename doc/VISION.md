# Claij: Self-Organizing LLM Society for Software Development
## Core Architectural Principles
- **Foundational Structured Messaging**: All interactions in the LLM society rely on structured JSON messages—both requests and responses—treated symmetrically as proposals. Each message is validated against schemas tied to FSM transitions, ensuring no invalid or hallucinated data slips through, with `additionalProperties: false` and `additionalItems: false` to lock down structures and prevent extra fields.
- **Finite State Machine (FSM) as Control Flow**: Building on structured messages, the FSM defines states as simple labels (e.g., human-init, mc-router, dev-llm-state) and transitions as schema-validated arcs with optional hooks for side-effects like tool execution. The FSM routes messages without inherent direction, firing transitions only when a proposal matches an outgoing schema, enabling reliable, decentralized coordination without central scripting.
- **Asynchronous Processing for Scalability**: Leveraging the FSM's transition-based flow, implement fully asynchronous HTTP requests and dispatches to handle thousands of in-flight messages without blocking threads. This allows the system to scale naturally, with the FSM tracking handles or IDs for replies, ensuring no orphaned processes while respecting timeouts or retries embedded in schemas.
- **Master of Ceremonies (MC) as Router and Orchestrator**: Depending on the FSM for routing, the MC acts as a triage node that sniffs incoming messages (e.g., user chat requests), reframes them into tasks or stories, and initiates sub-FSMs (e.g., story-task FSMs) for delegation to roles like developers. It enforces structure without performing work itself, routing to idle or appropriate agents while avoiding overload through natural constraints.
- **Kanban-Style Workflow Integration**: Using the MC and FSM, model workflows as Kanban boards with columns (e.g., backlog → ready-for-dev → dev → done), where the MC triggers meta-loops like retrospectives and planning refills when ready-for-dev empties. This hybrid includes WIP limits to cap concurrent stories and the potentially high number of developers working concurrently, borrowing Scrum elements like retros for self-improvement without rigid sprints.
- **Dependency Graphs from Planning**: In the planning phase orchestrated by the MC, generate a dependency graph of stories and tasks during ceremonies, topologically sorting it to populate ready-for-dev. This ensures parallelism emerges naturally (no artificial limits beyond WIP), with serial tasks waiting on predecessors' state, all routed via FSM transitions.
- **Role Assignment and Tool Execution**: Building on workflows and graphs, assign roles (e.g., coder, tester, toolsmith, documenter) via MC-routed FSM states, where states can represent entities like LLMs, humans, or tools (e.g., MCP for ls commands). Tools execute asynchronously, packaging results into structured responses that trigger further transitions back to LLMs or MC.
- **Memory Management Tied to FSM Paths**: Dependent on FSM traversal and dependency graphs, bound memory to the active path: log all prompts, requests, and responses raw during execution for perfect recall in prompts. At path end, summarize (pruning via forward-looking LLM analysis of future graph nodes) and feed into global or task-local memory, preventing ballooning while passing only necessary state to dependents. This optimizes token efficiency by keeping active prompts concise and reducing long-term storage to essentials.
- **Trail-Based Retries and Parallel Exploration**: Leveraging memory trails as sequences of requests and responses, enable stateless retries by providing any LLM with a trail to resume from a specific point. Support "Permutation City"-style cloning and merging: launch multiple parallel attempts at subgoals, gather trails from each, then select the best outcome or summarize collective experiences via LLM to inform dependent tasks, enhancing robustness and innovation.
- **Trunk-Based Development Practices**: Integrated with workflows, enforce small, granular stories committed directly to main/master without branches or PRs, using MC-enforced zone locks to prevent conflicts. Promote parallelism via API decoupling: vote on interfaces first, then scatter implementation, with toolsmith spotting patterns for reusable tools.
- **Emergent DSL for Efficiency**: As the society runs on structured messages and accumulates memory/logs, let agents dynamically evolve a domain-specific language (DSL) as a compression layer atop JSON. This shorthand (e.g., abbreviating repeated schemas) is negotiated via toolsmith or retros, inserted into prompts for efficiency, without replacing core JSON validation.
- **Self-Improvement and Bootstrapping**: Culminating from all elements, enable workflows that build themselves: start with seed schemas, then use LLMs to analyze and generate new FSMs, schemas, and prompts on-the-fly (e.g., for GitHub flows including tests). This creates a self-organizing system where prompts become modular code, evolving via retros and memory summaries for continuous refinement.
- **Multi-Modal Interface (Voice/Text)**: The system supports voice or text input from any device (mobile, desktop), linking all interactions to the same persistent development session for seamless continuity across platforms.
- **Dynamism**: All features—including roles, states, transitions, FSM, tools, schemas, DSLs, functions, LLM definitions, MCP definitions, prompts, and prompt combinations—can be created or modified dynamically without restarting the server. FSMs can even define themselves as they are traversed.
## Supporting Components
- **Audit and Monitoring**: Include an audit component logging hallucinations (failed validations), response times, tokens used, FSM traversal paths, error rates, and WIP bottlenecks. Use for comparing LLM models on efficiency, accuracy, and cost. Integrate monitoring for real-time metrics like active sessions, throughput, and token spend alerts, feeding back into retros for optimization.
- **Persistent Storage**: Use PostgreSQL with JSONB columns (or Datomic/XTDB for immutable versioning in Clojure) to store schemas, documents, prompts, and FSMs with version fields (e.g., timestamp, ID) for tracking changes.
- **Versioned JSON Service**: Employ services like JSONBin.io or myJson for RESTful storing/loading of versioned JSON documents with private bins and history.
- **User Interface**: Provide a web-based UI (e.g., via ClojureScript/Reagent) for viewing/editing JSON components like schemas, FSMs, and prompts, integrated with persistent storage for versioning and audit trails.
